#include <esp_now.h>
#include <WiFi.h>
#include <Wire.h>
#include "TFT_eSPI.h"
#include <TJpg_Decoder.h>
#include <FS.h>
#include "SPIFFS.h" 
#include  <math.h>
#include <stdio.h>


TFT_eSPI tft = TFT_eSPI();

bool tft_output(int16_t x, int16_t y, uint16_t w, uint16_t h, uint16_t* bitmap)
{
  if ( y >= tft.height() ) return 0;
  tft.pushImage(x, y, w, h, bitmap);
  return 1;
}

#define FS_NO_GLOBALS
// OLD Lora 
//#define ss 5
//#define rst 34
//#define dio0 35

#define RED 0xF800
int x_tile, y_tile, x_pix, y_pix;
float glob_x, glob_y;
double dlong, dlat;
char zoomBuffer[10];
int zoomLevel = 18;
//char la[9];
//char lo[9];
const uint8_t * mac;
const uint8_t *incomingData;
int len;
const String Ext = ".jpeg";
const String Slash = "/";
const long buttonInterval = 500; 
const int maxZoomLevel = 17;
const int minZoomLevel = 15;
String readlong;
String readlat;
String mapFile;
String xname = "";
String yname= "";
int x;
int y;
float lat;
float lon;
int mapHeight = 320;
int mapWidth = 480;

//Structure to receive data
//Over ESP-NOW
typedef struct test_struct {
  char x[10];
  char y[10];

} test_struct;

//Create a struct_message called myData
test_struct myData;

//callback function that will be executed when data is received
void OnDataRecv(const uint8_t * mac, const uint8_t *incomingData, int len) {

    // ESP-Now on recieve get out my lat long
    x = NULL;
    y = NULL;
    memcpy(&myData, incomingData, sizeof(myData));
    Serial.print("Bytes received: ");
    Serial.println(len);
    Serial.print("x: ");
    Serial.println(myData.x);
    String readStringlat(myData.x);
    readlat = readStringlat;
    Serial.print("y: ");
    Serial.println(myData.y);
    String readStringlong(myData.y);
    readlong = readStringlong;
    Serial.println();
    mapFile = "";
    lat = readlat.toFloat();
    lon = readlong.toFloat();
    //float dlat = readlat.toFloat();
    //float dlong = readlong.toFloat();
    //doit();
    main();
    
}



void setup() {

    //Initialize Serial Monitor
    Serial.begin(115200);
    
    //Set device as a Wi-Fi Station
    WiFi.mode(WIFI_STA);

    //Init ESP-NOW
    if (esp_now_init() != ESP_OK) {
        Serial.println("Error initializing ESP-NOW");
        return;
    }
    // Once ESPNow is successfully Init, register for recv CB to
    // get recv packer info
    esp_now_register_recv_cb(OnDataRecv);

    // Initialise SPIFFS
    if (!SPIFFS.begin()) {
        Serial.println("SPIFFS initialisation failed!");
        while (1) yield(); // Stay here twiddling thumbs waiting
    }
    Serial.println("\r\nInitialisation done.");

// Initialise tft screen
    tft.begin();
    tft.setRotation(3);
    tft.setTextColor(0xFFFF, 0x0000);
    tft.fillScreen(TFT_BLACK);
    tft.setSwapBytes(true); // We need to swap the colour bytes (endianess)
    // The jpeg image can be scaled by a factor of 1, 2, 4, or 8
    TJpgDec.setJpgScale(1);
    // The decoder must be given the exact name of the rendering function above
    TJpgDec.setCallback(tft_output);

    initScreen();
 
}
 
void loop() {

  
  
}

void initScreen(){

    // Inital boot screen with image             
    tft.fillScreen(TFT_WHITE);
    tft.setTextSize(1);
    tft.setTextColor(TFT_RED, TFT_WHITE);
    tft.setTextDatum(TC_DATUM);
    TJpgDec.drawFsJpg(0, 0, "/Intro.jpeg");
    tft.drawString("Waiting for Beacon...", 240, 50, 4);
}


void smoothscreen(){
      
    // Display map tile and plot x,y on screen
    
    TJpgDec.drawFsJpg(0, 0, mapFile);
    tft.fillCircle(x_pix, y_pix, 5, RED);
    delay(10000);
}


float inv_gudermannian(float y) {
    return log(tan((y + M_PI_2) / 2));
}

void get_lat_lng_tile(float lat, float lon, float *x, float *y, int zoomLevel){

    
    float lat_rad = lat * M_PI / 180.0;
    lat_rad = inv_gudermannian(lat_rad);

    *x = pow(2, zoomLevel) * (lon + 180.0) / 360.0;
    *y = pow(2, zoomLevel) * (M_PI - lat_rad) / (M_PI * 2);

}


void get_coords(float glob_x, float glob_y, int x_width, int y_width, int *x_tile, int *y_tile, int *x_pixel, int *y_pixel) {
    // assume glob_x = 1.2, glob_y = 2.5
    
    float x_tile_f = floor(glob_x);  // 1.0
    float y_tile_f = floor(glob_y); // 2.0

    
    *x_tile = (int) x_tile_f; // 1
    *y_tile = (int) y_tile_f; // 2
    
    xname = String((int)x_tile_f);
    yname = String((int)y_tile_f);
    String MapName = "";
    MapName = Slash + xname + yname + Ext;
    mapFile = MapName;
    
    // Look at tile (1,2)

    float x_frac = glob_x - x_tile_f; //.2
    float y_frac = glob_y - y_tile_f; //.5

    *x_pixel = (int) (((float) x_width) * x_frac); // x_width = 200px -> 200px * 0.2 = 40px
    *y_pixel = (int) (((float) y_width) * y_frac); // x_width = 200px -> 200px * 0.2 = 40px

}

int main(){

    //  calculate tile number from lat long and write to mapFile    
    get_lat_lng_tile(lat, lon, &glob_x, &glob_y, zoomLevel);
    printf("glob x,y: %f, %f\n", glob_x, glob_y);
    get_coords(glob_x, glob_y, mapWidth, mapHeight, &x_tile, &y_tile, &x_pix, &y_pix);
    printf("tile x,y: %d, %d\n", x_tile, y_tile);
    printf("px x,y: %d, %d\n", x_pix, y_pix);
    Serial.println(mapFile);
    smoothscreen();
   return 0;
}
